= The IC Identity Provider Specification
:toc2:
:toclevel: 4
:sectanchors:

== Introduction

This document describes and specifies the IC Identity Provider from various angles and at various levels of abstraction, namely:

 * High level goals, requirements and use cases
 * Overview of the security and identity machinery, including the interplay of identities, keys, delegations etc.
 * Interface as used by client applications, i.e. the OAUTH-based spec
 * The interface of the IDP _backend_, i.e. describing its contract at the Candid layer, as used by its frontend
 * Important implementation notes about the IDP backend
 * Internal implementation notes about the IDP frontend
 * Notes about deployment

== Goals, requirements and use cases

The identity provider allows users to

 * maintain a single identity on the internet computer
 * log into that identity using one out of a set of security devices
 * manage this set of security devices

Some functional requirements are

 * the identity is stable, even if the set of security devices changes
 * no need ever to remember secret information (but possibly per-user non-secret information)
 * the security device does not need to be manually touched upon every interaction with a client application; a login is valid for a certain amount of time

Some security requirements are

 * a client application frontend (i.e. relaying party) can use the user’s identity only on the canisters belonging to that frontend.
 * (many more, of course; apply common sense)


== Identity design and data model

A single canister with a well-known canister id (the _IDP canister id_) controls all user’s identities.

The user’s _main identity_ on the platform is a https://docs.dfinity.systems/public/#id-classes[_self-authenticating id_] that is derived from a https://hydra.dfinity.systems/latest/dfinity-ci-build/ic-ref.pr-319/interface-spec/1/index.html#canister-signatures[canister signature] public “key” based on the _IDP canister id_ and the user’s _seed_.

The user’s _seed_ is a smallish natural number chosen by the canister, also called the _User Number_ or User#. The encoding as the seed is the ASCII encoding of its decimal representation.

The User Number is the main index under which the IDP canisters stores data associated with the user, which is

* a set of _device information_, consisting of
- the device’s public key (DER-encoded)
- a device _alias_, chosen by the user to recognize the device
- an optional _credential id_, which is necessary for WebAuthN authentication

When a client application wants to log in as the user, it uses a _session key_ (e.g. Ed25519 or ECDSA), and by way of the OAUTH protocol (details below) obtains a https://docs.dfinity.systems/public/#authentication[_delegation chain_] that allows the session key to sign for the user’s main identity.

The delegation chain has length two:

1. The _first delegation_ delegates from the user’s main identity to the device’s public key. This delegation is created by the Canister, and signed using a https://hydra.dfinity.systems/latest/dfinity-ci-build/ic-ref.pr-319/interface-spec/1/index.html#canister-signatures[canister signature].
+
This delegation is unscoped (valid for all canisters) and has a lifetime of *TODO*.

2. The _second delegation_ delegates from the device’s public key to the session key. This delegation is created by the IDP frontend as part of the OAUTH protocol, and is signed using https://hydra.dfinity.systems/latest/dfinity-ci-build/ic-ref.pr-319/interface-spec/1/index.html#webauthn[WebAuth signature].
+
This delegation is scoped to the application canister whose frontend is initiating the OAUTH protocol, and has a lifetime of *TODO*.


== OAUTH protocol

This section describes the Identity Provider from the point of view of a client appliation frontend (a.k.a. the relaying party).

The OAUTH entry point URL is

  https://<idp_canister_id>.ic0.app/authorize

and the following parameters have particular relevance

* the `scope` parameter contains a space separated list of textual representations of canister ids, and indicates the set of canisters that the client application frontend would like to talk to as the user.
+
WARNING: *TODO* How to restrict this sensibly, and possibly connect to the callback URL?

* the `login_hint` parameter contains the public key of the session key created by the client application frontend, as a hex-encoded DER key.

If the Identity Provider frontend can authorize this request, the url parameters on the callback (i.e. the provided `redirect_uri`) contain in particular

* the `accessToken`, which is the hex-encoding of a JSON encoding of the delegation chain in the following format
+
....
{
  delegations: [
    { delegation: {
        expiration: (hex-encoded big-endian expiration date)
        pubkey: (hex-encoded DER-encoded public key of delegatee)
        targets: (optional)
          [ (hex-encoded binary canister id)
            …
          ]
      },
      signature: (hex-encoded signature)
    }
    …
  ],
  publicKey: (hex-encoded public key that forms the user’s main identity)
}
....
+
This structure can be converted by the client application into a CBOR-encoded delegation chain as used for https://docs.dfinity.systems/public/#authentication[_authentication on the IC_].

The client application frontend needs to be able to detect when either of the two delegations has expired, and re-authorize the user in that case.

The https://www.npmjs.com/package/@dfinity/authentication[`@dfinity/authetication` NPM package] provides functionality for this workflow.

== The backend: interface

This section describes the interface that the IDP canister provides.

This interface is currently only used by its frontend, so there is a tight coupling which means that this interface may change, even in incompatible ways. This means we do not have to apply Candid best practices for backward-compatibility (such as using records for arguments and results).

The summary is given by the following Candid interface (exluding the methods required for the https://www.notion.so/Design-HTTP-Requests-to-Canisters-d6bc980830a947a88bf9148a25169613[HTTP Gateway interface]):
....
type UserId = nat64;
type CredentialId = blob;
type Alias = text;
type Timestamp = nat64;
type PublicKey = blob;
type Delegation = record {
  pubkey: PublicKey;
  expiration: Timestamp;
  targets: opt vec principal;
};
type SignedDelegation = record {
  delegation: Delegation;
  signature: blob;
};
type GetDelegationResponse = variant {
  delegation: SignedDelegation;
  request_delegation_explicitly
};

service : {
  register : (Alias, PublicKey, opt CredentialId) -> (UserId);
  add : (UserId, Alias, PublicKey, opt CredentialId) -> ();
  remove : (UserId, PublicKey) -> ();
  lookup : (UserId) -> (vec record {Alias; PublicKey; Timestamp; opt CredentialId}) query;
  get_delegation: (UserId, PublicKey) -> (GetDelegationResponse) query;
  request_delegation : (UserId, PublicKey) -> ();
}
....

The `SignedDelegation` type is a direct translation from https://docs.dfinity.systems/public/#authentication[the IC interface spec].

=== The `register` method

The `register` method is used to create a new user and associate it with a first device, as in `add`.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from the given `PublicKey`.

The canister creates a _fresh_ UserId and returns it.

For a while after adding a key, the delegation can be fetched using `get_delegation`.

WARNING: *TODO*: This method will be protected by some form of proof of work or captcha, which needs involvement from the canister.

=== The `add` method

The `add` method is used to associate a new device with the user.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.

It is not allowed add a public key that has already been added to this user (changing the alias is not yet supported).

This may fail (with a _reject_) if the user is registering too many devices.

For a while after adding a key, the delegation can be fetched using `get_delegation`.

=== The `remove` method

The `remove` method removes a device from the list of devices a user has.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.

It is allowed to remove the key that is used to sign this request. This can be useful for a panic button functionality.

It is allowed to remove the last key, to completely disable a user. The canister may forget that user completely then, assuming the user id generation algorithm prevents new users from getting the same user id.

It is the responsibility of the frontend UI to protect the user from doing these things accidentally.

=== The `lookup` query method

Fetches all data associated with a user.

*Authorization*: Anyone can call this

=== The `get_delegation` query method

For a certain amount of time after a call to `register`, `add` or `request_delegation`, the (first) delegation including signature can be fetched by the frontend. This method will return `request_delegation_explicitly` if the provided user id and public key make sense, but the caniser has already pruned the signature. In that case, the frontned can use `request_delegation` to create a new signature and try again.

*Authorization*: Anyone can call this

=== The `request_delegation` method

The `request_delegation` method creates a new delegation signature to the given public key, which for a while can be fetched using `get_delegation`

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.

== The backend: internals

This section, which is to be expanded, describes interesting design choices about the internals of the IDP Canister. In particular

* Internal data model and data structures used

* Approach to upgrades

* Logic for signature/certified variable caching


== The frontend

The IDP frontend is the user-visible part of the Identity Provider, and where it all comes together. It communicates with

* the user
* the backend using the Candid interface described above
* the security devices, using the Web Authentication API
* its past and future self, via the browser storage
* client application frontend, via the OAUTH protocol

=== Storage used

The following storage keys in `localStorage` are used by the frontend

* `userid`: The user number, if known
* `identity`: The `WebAuthenicationIdentity`, as defined in `@dfinity/identity`, of the currently used device, if authenticated
* `delegation`: A delegation to the public key in `identity`, if already fetched

=== Flows

The following flows are not prescriptive of the UI, e.g. “the frontend asks the user for X” may also mean that on the previous shown page, there is already a field for X.

All update calls to the IDP canister are authenticated by the Identity stored in `identity`, all query calls are made anonymously.

All steps with 👆 are steps where the user presses the security device.

=== Flow: Initial Registration

1. The user accesses `/`
2. The frontend notices that no `userid` is present in local storage, and asks the user if they want to register, login with existing device, login with new security device. User presses register.
3. 👆 The frontend asks the security device to create a new public key. It generates a `WebAuthenicationIdentity` from that, and stores it as `identity`.
4. The frontend configures the agent to use this identity for all further calls.
5. The frontend asks the user for the device alias to use.
6. 👆 The frontend calls `register()`, and stores the resulting user number as `userid`.
7. The frontend queries `get_delegation()`, and stores the resulting delegation as `delegation`.
8. The frontend shows (or redirects to) the “logged in view”

=== Flow: Automatic relogin

1. The user accesses `/`
2. The frontend notices that `userid` is present.
3. The frontend shows (or redirects to) the “logged in view”

Note: The security device is _not_ used here!


=== Flow: Manual relogin with existing device

1. The user accesses `/`
2. The frontend notices that no `userid` is present in local storage, and asks the user if they want to register, login with existing device, login with new security device. User presses login with existing device.
3. The frontend asks the user for its user id, and stores that in `userid`.
4. Frontend fetches list of devices.
5. 👆 For each device, frontend tries to create a signature for a call to `request_delegation`. This will fail for all non-present devices, and succeed for the present device.
6. The found devices is stored in `identity`
7. The `request_delegation()` request is sent.
8. The frontend queries `get_delegation()`, and stores the resulting delegation as `delegation`.
9. The frontend shows (or redirects to) the “logged in view”

=== Flow: Manual login with new device

1. The user accesses `/`
2. The frontend notices that no `userid` is present in local storage, and asks the user if they want to register, login with existing device, login with new security device. User presses login with new device.
3. The frontend asks the user for its user id, and stores that in `userid`.
4. 👆 Frontend asks security device for a new public key (and credential id).
5. The frontend generates a link to be opened on another device where an existing authentication device exists.
+
The link format is:
+
  https://<idp_canister_id>.ic0.app/manage.html?device=<userId>;<publicKey>[;<credentialId>]
+
where
+
- `userId` is the user id, as a decimal number
- `publicKey` is the hex-encoded DER-encoded WebAuth public key
- `credentialId`, if present, is the hex-encoded credential id required for this key

6. On other device’s frontend: Extract `userid`, `publicKey` and `credentialid` from link
7. The frontend asks the user for the device alias to use.
8. 👆 On other device’s frontend:
- If `identity` is present, continue to use that to sign the `add()` call.
- If `identity` is not present, fetch all devices (as in “Flow: Manual relogin with existing device” and try to sign call to `add()` with that.
9. On other device’s frontend: Call `add()` to add new device
10. On other device’s frontend: Tell user to go back to first computer
11. The frontend polls `lookup` to see when it has been authorized
12. Once it sees its own identity: Remember it as `identity`
13. The frontend queries `get_delegation()`, and stores the resulting delegation as `delegation`.
14. The frontend shows (or redirects to) the “logged in view”

=== Flow: OAUTH

1. The user accesses `/authorize` with oauth parameters
2. (👆) Now login flows as above happen, while keeping the oauth parameters around.
    At the end of these flows, instead of showing (or redirecting to) the “logged in view”, the frontend does the following steps:
3. (👆) The frontend checks that the delegation in `delegation` is still valid long enough. If not, it calls `request_delegation` to fetch a new one.
4. It creates the second delegation from the current `identity` to the public key mentioned in the `login_hint` of the OAUTH request.
5. 👆 It signs that delegation using the current security device.
6. It forwards the delegation chain (first and section) to the relaying party, as required by the oauth protocol

=== Flow: Managing devices

To be done: Which flows are supported by the “logged in view” (e.g. removing keys, editing aliases)

== Deployment

This section needs to describe aspects like

* why and how the frontend is bundled with and served by the canister itself.
* integration into the network bootstrap
* how upgrades are rolled out
* how the IDP canister id stays predictable and well-known
